// Generated by CoffeeScript 1.9.1
(function() {
  var edgy,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  edgy = angular.module('edgy', []);

  edgy.directive('viewer', function($window) {
    return {
      replace: true,
      transclude: true,
      template: '<main ng-transclude></main>',
      controller: function($scope, $element) {
        if ($scope.zoom == null) {
          $scope.zoom = 8;
        }
        if ($scope.width == null) {
          $scope.width = 32;
        }
        if ($scope.height == null) {
          $scope.height = 48;
        }
        if ($scope.sync == null) {
          $scope.sync = false;
        }
        if ($scope.color == null) {
          $scope.color = 'black';
        }
        return $scope.save = function() {
          var div, height, image, svgElement, width;
          width = $scope.width, height = $scope.height;
          svgElement = $element.find('svg');
          div = angular.element('<div />').append($element.find('svg').clone(true));
          div.find('svg').attr({
            width: width,
            height: height
          });
          div.find('rect').remove();
          div.find('clipPath').remove();
          div.find('g').removeAttr('clip-path');
          image = new Image;
          image.src = 'data:image/svg+xml;base64,' + btoa(div[0].innerHTML);
          return image.onload = function() {
            var context;
            context = $window.document.createElement('canvas').getContext('2d');
            context.canvas.width = $scope.width;
            context.canvas.height = $scope.height;
            context.drawImage(image, 0, 0);
            return $window.open(context.canvas.toDataURL());
          };
        };
      }
    };
  });

  edgy.factory('Sound', function($window) {
    var AudioContext, Sound;
    AudioContext = $window.AudioContext || $window.webkitAudioContext;
    Sound = (function() {
      function Sound(url) {
        var xhr;
        if (AudioContext == null) {
          return this;
        }
        xhr = new XMLHttpRequest;
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.send();
        xhr.onload = (function(_this) {
          return function() {
            _this.pcm = new AudioContext;
            return _this.pcm.decodeAudioData(xhr.response, function(buffer) {
              return _this.source = buffer;
            });
          };
        })(this);
      }

      Sound.prototype.play = function() {
        var source;
        if (AudioContext == null) {
          return this;
        }
        if (this.coolTime != null) {
          return;
        }
        source = this.pcm.createBufferSource();
        source.buffer = this.source;
        source.connect(this.pcm.destination);
        source.start(0);
        this.coolTime = true;
        return setTimeout(((function(_this) {
          return function() {
            return _this.coolTime = null;
          };
        })(this)), 100);
      };

      return Sound;

    })();
    return Sound;
  });

  edgy.factory('Art', function($window, $rootScope, Sound) {
    var Art;
    Art = (function(superClass) {
      extend(Art, superClass);

      function Art(svgElement1) {
        this.svgElement = svgElement1;
        Art.__super__.constructor.call(this);
        this.foreground = angular.element(this.svgElement).find('g');
        this.putSound = new Sound('data:audio/wav;base64,UklGRogBAABXQVZFZm10IBAAAAABAAEAIlYAACJWAAABAAgAZGF0YWQBAACAh4mLjpCSlJaYmpyeoKGjpaeoqqyqpaGcmJSQjIiEgH15e3l4dnRzcXBubGtrbW9xc3V2eHp7fX+BgoSFh4mKjI2PkZKUlZaWlpWVlZSUlJOTk5OSkpKSkZGRkJCQkI+Pj4+Ojo6Ojo6Ojo6Ojo6Ojo2NjY2NjY2NjY2MjIyMjIyMjIyLi4uKiomJiYiIh4eHhoaGhYWFhISEg4OFhISEg4ODgoKCgYGBgYGBgYGBgYGBgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgA==');
        this.colors = [];
        this.position = {};
      }

      Art.prototype.remind = function() {
        var colors, position;
        if (this.coolTime) {
          return;
        }
        this.coolTime = true;
        $window.setTimeout(((function(_this) {
          return function() {
            return _this.coolTime = false;
          };
        })(this)), 250);
        colors = this.colors, position = this.position;
        return this.add({
          colors: colors,
          position: position
        });
      };

      Art.prototype.update = function(width1, height1, zoom1, color1, sync) {
        var changedColor, element, height, ref, ref1, scaleX, scaleY, validColor, width;
        this.width = width1;
        this.height = height1;
        this.zoom = zoom1;
        this.color = color1;
        element = angular.element(this.svgElement);
        element.attr({
          width: width,
          height: height
        });
        element.attr({
          'version': '1.1',
          'xmlns': 'http://www.w3.org/2000/svg',
          'xmlns:xlink': 'http://www.w3.org/1999/xlink',
          'shape-rendering': 'crispEdges',
          'viewBox': "0 0 " + this.width + " " + this.height
        });
        ref = this.svgElement.parentNode.getBoundingClientRect(), width = ref.width, height = ref.height;
        scaleX = this.width / width * 100 * this.zoom;
        scaleY = this.height / height * 100 * this.zoom;
        element.css({
          width: scaleX + '%',
          height: scaleY + '%'
        });
        validColor = (this.oldColor != null) && (this.color != null);
        changedColor = validColor && this.color !== this.oldColor;
        if (changedColor && sync) {
          if (ref1 = this.oldColor, indexOf.call(this.colors, ref1) >= 0) {
            this.colors[this.colors.indexOf(this.oldColor)] = this.color;
          }
        }
        this.oldColor = this.color;
        if (changedColor && sync) {
          return this.remind();
        }
      };

      Art.prototype.render = function() {
        var color, d, i, line, path, paths, ref, x, y;
        this.foreground.empty();
        paths = {};
        ref = this.position;
        for (x in ref) {
          line = ref[x];
          for (y in line) {
            i = line[y];
            color = this.colors[i];
            if (paths[color] == null) {
              paths[color] = '';
            }
            paths[color] += 'M' + x + ',' + y + 'h1v1h-1Z';
          }
        }
        for (color in paths) {
          d = paths[color];
          path = $window.document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttributeNS(null, 'fill', color);
          path.setAttributeNS(null, 'd', d);
          this.foreground.append(angular.element(path));
        }
        $rootScope.undo = (function(_this) {
          return function() {
            _this.undo(true);
            return _this.render();
          };
        })(this);
        $rootScope.redo = (function(_this) {
          return function() {
            _this.redo(true);
            return _this.render();
          };
        })(this);
      };

      Art.prototype.stroke = function(point, pointPrev) {
        var i, j, len, ref, ref1, x, y;
        if ((isNaN(point.x)) || (isNaN(point.y))) {
          return;
        }
        x = point.x, y = point.y;
        if (this.color != null) {
          if (ref = this.color, indexOf.call(this.colors, ref) < 0) {
            this.colors.push(this.color);
          }
          i = this.colors.indexOf(this.color);
        }
        this.put(i, x, y);
        if (pointPrev != null) {
          ref1 = this.getPoints(point, pointPrev);
          for (j = 0, len = ref1.length; j < len; j++) {
            point = ref1[j];
            this.put(i, point.x, point.y);
          }
        }
        if (this.color != null) {
          this.putSound.play();
        }
        return this.render();
      };

      Art.prototype.put = function(i, x, y) {
        var base;
        if ((base = this.position)[x] == null) {
          base[x] = {};
        }
        if (this.color != null) {
          return this.position[x][y] = i;
        } else {
          return delete this.position[x][y];
        }
      };

      Art.prototype.get = function(point) {
        var color, i, ref;
        color = null;
        i = (ref = this.position[point.x]) != null ? ref[point.y] : void 0;
        if (i != null) {
          color = this.colors[i];
        }
        return color;
      };

      Art.prototype.getPoints = function(next, prev) {
        var i, points, x, y;
        points = [];
        i = 0;
        x = next.x, y = next.y;
        while (!(x === prev.x && y === prev.y)) {
          if (x < prev.x) {
            x++;
          }
          if (x > prev.x) {
            x--;
          }
          if (y < prev.y) {
            y++;
          }
          if (y > prev.y) {
            y--;
          }
          points.push({
            x: x,
            y: y
          });
          i++;
          if (i > 100) {
            break;
          }
        }
        return points;
      };

      Art.prototype.getPoint = function(event, scope) {
        var height, point, ref, width, x, y;
        ref = this.getOffset(event), x = ref.x, y = ref.y, width = ref.width, height = ref.height;
        x = ~~(x / width * scope.width);
        y = ~~(y / height * scope.height);
        return point = {
          x: x,
          y: y
        };
      };

      Art.prototype.getOffset = function(event) {
        var height, layerX, layerY, offset, offsetX, offsetY, ref, ref1, scrollLeft, scrollTop, width, x, y;
        layerX = event.layerX, layerY = event.layerY, offsetX = event.offsetX, offsetY = event.offsetY;
        ref = this.svgElement.parentNode, scrollTop = ref.scrollTop, scrollLeft = ref.scrollLeft;
        ref1 = this.svgElement.getBoundingClientRect(), width = ref1.width, height = ref1.height;
        x = layerX != null ? layerX : offsetX;
        x += scrollLeft;
        y = layerY != null ? layerY : offsetY;
        y += scrollTop;
        return offset = {
          x: x,
          y: y,
          width: width,
          height: height
        };
      };

      return Art;

    })(HistoryJson);
    return Art;
  });

  edgy.directive('art', function(Art, $window, $rootScope) {
    return {
      require: '^viewer',
      replace: true,
      template: '<svg ng-attr-width="{{width}}" ng-attr-height="{{height}}">\n  <defs>\n    <pattern id="background" width="1" height="1" patternUnits="userSpaceOnUse">\n      <path transform="scale(.25)" fill="rgba(0,0,0,0.05)" d="M0,0h1v1h-1ZM3,0h1v1h-1ZM2,1h2v1h-2ZM1,2h2v1h-2ZM0,3h2v1h-2Z"></path>\n    </pattern>\n  </defs>\n  <rect id="canvas" fill="url(#background)" ng-attr-width="{{width}}" ng-attr-height="{{height}}"></rect>\n  <clipPath id="clip">\n    <use xlink:href="#canvas"/>\n  </clipPath>\n  <g clip-path="url(#clip)">\n    \n  </g>\n</svg>',
      templateNamespace: 'svg',
      link: function(scope, element, attrs) {
        var art, pointPrev;
        art = new Art(element[0]);
        art.remind();
        scope.$watch(function() {
          var color, height, sync, width, zoom;
          width = scope.width, height = scope.height, zoom = scope.zoom, color = scope.color, sync = scope.sync;
          art.update(width, height, zoom, color, sync);
          return art.render();
        }, true);
        pointPrev = null;
        element.on('mousedown', function(event) {
          var point;
          if (event.which === 3) {
            return;
          }
          event.preventDefault();
          point = art.getPoint(event, scope);
          art.stroke(point);
          return pointPrev = point;
        });
        element.on('mousemove', function(event) {
          var point;
          if (pointPrev == null) {
            return;
          }
          point = art.getPoint(event, scope);
          art.stroke(point, pointPrev);
          return pointPrev = point;
        });
        angular.element($window).on('mouseup', function(event) {
          if (pointPrev == null) {
            return;
          }
          return art.remind();
        });
        angular.element($window).on('mouseup', function(event) {
          var point;
          if (pointPrev == null) {
            return;
          }
          point = art.getPoint(event, scope);
          if (event.target === art.svgElement) {
            art.stroke(point, pointPrev);
          }
          return pointPrev = null;
        });
        return element.on('contextmenu', function(event) {
          var point;
          event.preventDefault();
          point = art.getPoint(event, scope);
          scope.$parent.color = art.get(point);
          return scope.$parent.$apply();
        });
      }
    };
  });

}).call(this);

//# sourceMappingURL=index.js.map
